/*******************************************************************************
* Copyright 2016-2020 Intel Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#include <assert.h>
#include <math.h>

#include "common/c_types_map.hpp"
#include "common/dnnl_thread.hpp"
#include "common/nstl.hpp"
#include "common/type_helpers.hpp"
#include "common/ve/memory_desc_wrapper_opt.hpp" // we use CoordsFor vectorization helper.

#include "cpu/simple_q10n.hpp"
#include "cpu/ref_pooling.hpp"
//#include "cpu/ve/hoist.hpp"

#define IMPL 52
// 0 close to original
// 1 inner-loop rewrite (old)
// 2 inner-loop rewrite (old)
// 3 outer loop vec, inner loop~0
// 4 outer loop vec, inner loop~2
// 5 ker_maxb
// 6 ker_maxc
// VE timings:
// test case: --tag=aBx16b --alg=MAX,AVG_NP,AVG_P --dir=FWD_D,BWD_D mb1ic32_ih300iw500_oh151ow251_kh3kw3_sh2sw2_ph1pw1
//      fwd-max bwd-max fwd-avg bwd-avg
// 00   532     1232    480     628
// 01   531     430     
// 11   599     419
// 21   705     434
// 21'  636
// 31   557     418
// 41   572     423
// 51  *421*    421  XXX TODO take IMPL==5 and try for masked vector findmax asm (should be possible)
// 61   508     429
// 50:3 204     587 ***
// 51:0 190     478
// 51:1 189             (VecPos32)
// 51:2 189             (vp[][] base pointers outside inner loop)
// 51:10 194
// 51:11 186    // max vec movement out of inner loop (scalar read vs recalc)
// 52 = cleanup of 51:11
// Observed?
//   little effect of gathering into local vec and later scattering ? (sometimes this is a good idea)

// backwards 0~original, 1~outer vec offsets
#define BIMPL 1
// 0 ~ 1232 ms
// 1 ~ 430 ms (even without inner-loops vectorized)

#ifndef MVL
#if defined(__ve)
#define MVL 256
#else
#define MVL 32
#endif
#endif
#define LISTVEC PragmaQuote(_NEC list_vector)
#define NOVEC   PragmaQuote(_NEC novector);

namespace dnnl {
namespace impl {
namespace cpu {

static inline dim_t get_offset(
        const memory_desc_wrapper &mdw, int n, int c, int d, int h, int w) {
    switch (mdw.ndims()) {
        case 3: return mdw.off(n, c, w);
        case 4: return mdw.off(n, c, h, w);
        case 5: return mdw.off(n, c, d, h, w);
        default: assert(!"Invalid tensor dimension in pooling");
    }
    return 0;
}

using namespace nstl;

#if 0 
static void mdw_prt(char const* msg, memory_desc_wrapper const& mdw){
    char a[128], b[128];
    dnnl_md2fmt_str(a,128,mdw.md_);
    dnnl_md2dim_str(b,100,mdw.md_);
    printf(" %s %s %s\n", msg, a, b);
    fflush(stdout);
}
#endif

template <data_type_t data_type, data_type_t acc_type>
void ref_pooling_fwd_t<data_type, acc_type>::execute_forward(
        const exec_ctx_t &ctx) const {

    auto src = CTX_IN_MEM(const data_t *, DNNL_ARG_SRC);
    auto dst = CTX_OUT_MEM(data_t *, DNNL_ARG_DST);
    auto ws = CTX_OUT_MEM(unsigned char *, DNNL_ARG_WORKSPACE);

    const memory_desc_wrapper src_d(pd()->src_md());
    const memory_desc_wrapper dst_d(pd()->dst_md());
    const memory_desc_wrapper ws_d(pd()->workspace_md());

    assert( src_d.ndims() >= 3 );
    assert( src_d.ndims() <= 5 );
    assert( dst_d.ndims() == src_d.ndims() );
    assert( src_d.format_kind() == format_kind::blocked );
    assert( dst_d.format_kind() == format_kind::blocked );

    const memory_desc_wrapper_opt src_d_opt(src_d.md_);
    const memory_desc_wrapper_opt dst_d_opt(dst_d.md_);
    const memory_desc_wrapper_opt *ws_d_opt{nullptr};


    auto alg = pd()->desc()->alg_kind;
    const data_type_t ws_dt = ws ? ws_d.data_type() : data_type::undef;

    if (ws) assert(ws_dt == data_type::u8 || ws_dt == data_type::s32);
    if (ws) {
        //mdw_prt("yes ws:", ws_d);
        assert(ws_dt == data_type::u8 || ws_dt == data_type::s32);
        assert(alg == alg_kind::pooling_max);
        assert( ws_d.format_kind() == format_kind::blocked );
        // avoid init and setup cost if possible
        ws_d_opt = new memory_desc_wrapper_opt(ws_d.md_);
    } // else NO guarantees on ws_d content

    const int ID = pd()->ID();
    const int IH = pd()->IH();
    const int IW = pd()->IW();
    const int KD = pd()->KD();
    const int KH = pd()->KH();
    const int KW = pd()->KW();
    const int SD = pd()->KSD();
    const int SH = pd()->KSH();
    const int SW = pd()->KSW();
    const int padF = pd()->padFront();
    const int padT = pd()->padT();
    const int padL = pd()->padL();

    typedef CoordsForNd<6,uint64_t,uint64_t> Coords;

#ifndef NDEBUG
    if (ws && ws_dt == data_type::u8) {
        assert( KD * KH * KW <= numeric_limits<typename prec_traits<
                data_type::u8>::type>::max());
    }
#endif

    auto set_ws = [=](int mb, int oc, int od, int oh, int ow, int value) {
        dim_t off = -1; // "invalid" return offset
        if (ws) {
            off = get_offset(ws_d, mb, oc, od, oh, ow);
            if (ws_dt == data_type::u8) {
                //assert(0 <= value
                //        && value <= numeric_limits<typename prec_traits<
                //                        data_type::u8>::type>::max());
                ws[off] = value;
            } else
                reinterpret_cast<int *>(ws)[off] = value;
        }
        return off;
    };

    auto set_ws_off = [=](dim_t ws_off, int value) {
        if (ws && ws_off >= 0) {
            if (ws_dt == data_type::u8) {
                assert(0 <= value
                        && value <= numeric_limits<typename prec_traits<
                                        data_type::u8>::type>::max());
                ws[ws_off] = value;
            } else
                reinterpret_cast<int *>(ws)[ws_off] = value;
        }
    };

    auto ker_max = [=](data_t *d, int const mb, int const oc, int const od, int const oh, int const ow, dim_t const ws_off) {
#if IMPL==0 || IMPL==3 // 86 ms --pool --tag=aBx16b mb1ic32ih300iw500oh151ow251kh3kw3sh2sw2ph1pw1
        for (int kd = 0; kd < KD; ++kd) {
            const int id = od * SD - padF + kd;
            if (id < 0 || id >= ID) continue;
            for (int kh = 0; kh < KH; ++kh) {
                const int ih = oh * SH - padT + kh;
                if (ih < 0 || ih >= IH) continue;
                for (int kw = 0; kw < KW; ++kw) {
                    const int iw = ow * SW - padL + kw;
                    if (iw < 0 || iw >= IW) continue;

                    const auto off = get_offset(src_d, mb, oc, id, ih, iw);
                    auto s = src[off];
                    if (s > d[0]) {
                        d[0] = s;
                        set_ws_off(ws_off, (kd * KH + kh) * KW + kw);
                    }
                }
            }
        }
#elif IMPL==1 // 94 ms SLOWER 
        int const id0 = od * SD - padF; // input coord for kernel coord kd==0
        int const ih0 = oh * SH - padT;
        int const iw0 = ow * SW - padL;
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
        auto var_st  = (shift       >   0 ? shift: 0); \
        auto var_end = (shift + ksz < isz ? shift + ksz: isz);
        DEFINE_IN_RANGE(d_st, d_en, id0, KD, ID);
        DEFINE_IN_RANGE(h_st, h_en, ih0, KH, IH);
        DEFINE_IN_RANGE(w_st, w_en, iw0, KW, IW);

        int kpos = 0;
        for_(int id = d_st; id < d_en; ++id)
        for_(int ih = h_st; ih < h_en; ++ih)
        for (int iw = w_st; iw < w_en; ++iw) {
            const auto off = get_offset(src_d, mb, oc, id, ih, iw);
            auto s = src[off];
            //printf("id,ih,iw=%d,%d,%d off=%ld, kpos=%d\n",
            //        (int)id, (int)ih,(int)iw, (long)off,
            //        (int)(((id-id0) * KH + (ih-ih0)) * KW + (iw-iw0)) );
            if(s > d[0]) {
                d[0] = s;
                //int const kd = id - id0;
                //int const kh = ih - ih0;
                //int const kw = iw - iw0;
                //assert( kd >= 0 && kd < KD );
                //assert( kh >= 0 && kh < KH );
                //assert( kw >= 0 && kw < KW );
                kpos = ((id-id0) * KH + (ih-ih0)) * KW + (iw-iw0);
                //set_ws_off(ws_off, ((id-id0) * KH + (ih-ih0)) * KW + (iw-iw0));
            }
        }
        set_ws_off(ws_off, kpos); // still slow
#elif IMPL==2 || IMPL==4
        int const id0 = od * SD - padF; // input coord for kernel coord kd==0
        int const ih0 = oh * SH - padT;
        int const iw0 = ow * SW - padL;
        // src coords always used, kern coords calc only for max src value
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
        auto var_st  = (shift       >   0 ? shift: 0); \
        auto var_end = (shift + ksz < isz ? shift + ksz: isz);
        // src spatial window ranges
        DEFINE_IN_RANGE(d_st, d_en, id0, KD, ID);
        DEFINE_IN_RANGE(h_st, h_en, ih0, KH, IH);
        DEFINE_IN_RANGE(w_st, w_en, iw0, KW, IW);

        auto const dm = src_d_opt.ndims();
        typedef CoordsForNd<6,uint64_t,uint64_t> Coords;
        auto scrd= (dm >= 5)? Coords::mk(mb,mb+1, oc,oc+1, d_st,d_en, h_st,h_en, w_st,w_en)
            : (dm >= 4)? Coords::mk(mb,mb+1, oc,oc+1, h_st,h_en, w_st,w_en)
            : Coords::mk(mb,mb+1, oc,oc+1, w_st,w_en); // dm>=3
        // scrd coords reflect mb,oc,id,ih,iw
        data_t srcmax = numeric_limits<data_t>::lowest();
        int kkpos=0;
        dim_t srcp[MVL];
        NOVEC for ( ; scrd; ++scrd) {
            const unsigned vl=scrd.get_vl(); // vl ~ id,ih,iw coords
            // still uses vfrmax (VFMAX op)
            src_d_opt.vec_off_vtmp(scrd.base(), (dim_t *)&srcp[0], vl);
            int jmax = -1;
            ShortLoop() for(unsigned j=0U; j<vl; ++j) {
                auto const s= src[srcp[j]];
                if ( s > srcmax ) {
                    srcmax = s;
                    jmax = j;
                }
            }
            if(jmax >= 0 && ws_off >= 0){
                // given imax, calc kd,kh,kw --> kpos --> ws
                //kd = dm >= 5? scrd.vp[dm-3][jmax] - id0: 0;
                //kh = dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0;
                //kw =          scrd.vp[dm-1][jmax] - iw0   ;
                //assert( kd >= 0 && kd < KD );
                //assert( kh >= 0 && kh < KH );
                //assert( kw >= 0 && kw < KW );
                //auto off = get_offset(ws_d, mb, oc, od, oh, ow);
                //assert( off == ws_off );
                //set_ws_off(ws_off, (kd * KH + kh) * KW + kw);
                //kkpos = (kd * KH + kh) * KW + kw;
                kkpos = ((dm >= 5? scrd.vp[dm-3][jmax] - id0: 0)//kd
                        * KH
                        + (dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0))//kh
                        * KW
                        + (scrd.vp[dm-1][jmax] - iw0);//kw
            }
        }
        d[0] = srcmax;
        set_ws_off(ws_off, kkpos);
#elif IMP==20
        int const id0 = od * SD - padF; // input coord for kernel coord kd==0
        int const ih0 = oh * SH - padT;
        int const iw0 = ow * SW - padL;
#if 1
        // Maybe we really want the kd,kh,kw limits for which id,ih,iw are in range
        int kdlo, kdhi, khlo, khhi, kwlo, kwhi;
        //hoist_ApiB(kdlo, kdhi, 0,KD, od*SD-padF,1 0, ID); // id=(od*SD-padF)+(1)*kd
        // But since a+ib with b==1, it is much simpler
        kdlo = 0 - id0;
        kdhi = ID - id0;
        if (kdlo < 0) kdlo = 0;
        if (kdhi > KD) kdhi = KD;
        khlo = 0 - ih0;
        khhi = IH - ih0;
        if (khlo < 0) khlo = 0;
        if (khhi > KH) khhi = KH;
        kwlo = 0 - iw0;
        kwhi = IW - iw0;
        if (kwlo < 0) kwlo = 0;
        if (kwhi > KW) kwhi = KW;
#else
        int const kdlo = ( 0 - id0 >= 0?  0 - id0: 0);
        int const kdhi = (ID - id0 >= 0? ID - id0: 0);
        int const khlo = ( 0 - ih0 >= 0?  0 - ih0: 0);
        int const khhi = (IH - ih0 >= 0? IH - ih0: 0);
        int const kwlo = ( 0 - iw0 >= 0?  0 - iw0: 0);
        int const kwhi = (IW - iw0 >= 0? IW - iw0: 0);
#endif
        // source coords
        typedef CoordsForNd<6,uint64_t,uint64_t> Coords;
        // coords MUST match src ndims
        auto const dm = src_d_opt.ndims();
        auto cf = (dm >= 5)? Coords::mk(mb,mb+1, oc,oc+1,
                kdlo,kdhi,
                khlo,khhi,
                kwlo,kwhi)
            : (dm >= 4)? Coords::mk(mb,mb+1, oc,oc+1,
                    khlo,khhi,
                    kwlo,kwhi)
            : /*(dm >= 3)?*/ Coords::mk(mb,mb+1, oc,oc+1,
                    kwlo,kwhi);
        for ( ; cf; ++cf) { // can modify cf.vp w/o affecting kd,kh,kw iteration
            unsigned const vl = cf.get_vl();
            dim_t srcp[MVL];
            int kpos[MVL];
            for(unsigned i=0; i<vl; ++i){
                // remember kernel pos
                kpos[i] = (cf.vp[2][i] * KH + cf.vp[3][i]) * KW + cf.vp[4][i];
                // xform vp to ih,id,iw coords
                cf.vp[2][i] += id0;
                cf.vp[3][i] += ih0;
                cf.vp[4][i] += iw0;
            }
            src_d_opt.vec_off_v(cf.base(), &srcp[0], vl);
            // search for position of max src value
            int imax=0;
            for(unsigned i=0; i<vl; ++i){
                if (src[srcp[i]] > d[0]) imax = i;
            }
            set_ws_off(ws_off, kpos[imax]);
        }
#elif IMP==21
        int const id0 = od * SD - padF; // input coord for kernel coord kd==0
        int const ih0 = oh * SH - padT;
        int const iw0 = ow * SW - padL;
        typedef CoordsForNd<6,uint64_t,uint64_t> Coords;
        // coords MUST match src ndims
        auto const dm = src_d_opt.ndims();
        auto cf = (dm >= 5)? Coords::mk(mb,mb+1, oc,oc+1,
                ( 0 - id0 >= 0?  0 - id0: 0), (ID - id0 < ID? ID - id0: ID),
                ( 0 - ih0 >= 0?  0 - ih0: 0), (IH - ih0 < IH? IH - ih0: IH),
                ( 0 - iw0 >= 0?  0 - iw0: 0), (IW - iw0 < IW? IW - iw0: IW));
            : (dm >= 4)? Coords::mk(mb,mb+1, oc,oc+1,
                ( 0 - ih0 >= 0?  0 - ih0: 0), (IH - ih0 < IH? IH - ih0: IH),
                ( 0 - iw0 >= 0?  0 - iw0: 0), (IW - iw0 < IW? IW - iw0: IW));
            : /*(dm >= 3)?*/ Coords::mk(mb,mb+1, oc,oc+1,
                ( 0 - iw0 >= 0?  0 - iw0: 0), (IW - iw0 < KW? IW - iw0: KW));
        for ( ; cf; ++cf) { // can modify cf.vp w/o affecting kd,kh,kw iteration
            unsigned const vl = cf.get_vl();
            int kpos[MVL];
            for(unsigned i=0; i<vl; ++i){
                // remember kernel pos, cf ~ kernel coords
                kpos[i] = (cf.vp[2][i] * KH + cf.vp[3][i]) * KW + cf.vp[4][i];
                cf.vp[2][i] += id0;     // xform to input coords
                cf.vp[3][i] += ih0;
                cf.vp[4][i] += iw0;
            }
            dim_t srcp[MVL];            // physical src offset
            src_d_opt.vec_off_v(cf.base(), &srcp[0], vl); // cf ~ input coords
            // search for position of max src value
            int imax=0;
            for(unsigned i=0; i<vl; ++i){
                if (src[srcp[i]] > d[0]) imax = i;
            }
            set_ws_off(ws_off, kpos[imax]);
        }
#endif
    };

#if IMPL==5
     auto ker_maxb = [=](data_t *d, dim_t const ws_off,
             int mb, int oc, int od, int oh, int ow) {
         // this loops are better written in prep for vectorizn as IMPL 1 on ds08
         int kpos = 0;
         data_t srcmax = numeric_limits<data_t>::lowest();
         for (int kd = 0; kd < KD; ++kd) {
             const int id = od * SD - padF + kd;
             if (id < 0 || id >= ID) continue;
             for (int kh = 0; kh < KH; ++kh) {
                 const int ih = oh * SH - padT + kh;
                 if (ih < 0 || ih >= IH) continue;
                 for (int kw = 0; kw < KW; ++kw) {
                     const int iw = ow * SW - padL + kw;
                     if (iw < 0 || iw >= IW) continue;
 
                     const auto off = get_offset(src_d, mb, oc, id, ih, iw);
                     auto s = src[off];
                     if (s > srcmax) {
                         srcmax = s;
                         //set_ws_off(ws_off, (kd * KH + kh) * KW + kw);
                         kpos = (kd * KH + kh) * KW + kw;
                     }
                 }
             }
         }
         d[0] = srcmax;
         set_ws_off(ws_off, kpos);
     };
#endif
#if IMPL==9
     auto ker_maxb = [=](data_t *d, dim_t const ws_off,
             int mb, int oc, int od, int oh, int ow) {
         int kpos = 0;
         data_t srcmax = numeric_limits<data_t>::lowest();
         // issues with correct compilation
         for (int kd = 0; kd < KD; ++kd) {
             for (int kh = 0; kh < KH; ++kh) {
                 for (int kw = 0; kw < KW; ++kw) {
                     const int id = od * SD - padF + kd;
                     const int ih = oh * SH - padT + kh;
                     const int iw = ow * SW - padL + kw;
                     bool ok = 
                             (id >= 0 && ih >=0 && iw >= 0
                              && id < ID && ih < IH && iw < IW);
                     if(!ok) continue;
                     dim_t off = get_offset(src_d, mb, oc, id, ih, iw);
                     auto s = src[off];
                     if (s > srcmax){
                         srcmax = s;
                         kpos = (kd * KH + kh) * KW + kw;
                     }
                 }
             }
         }

         d[0] = srcmax;
         set_ws_off(ws_off, kpos);
     };
#endif
 
#if IMPL==6 || IMPL==50
     auto ker_maxc = [=](dim_t const* d_off, dim_t const* ws_off, Coords const& dcrd) {
         // d_crd.vp[j][i] for j=0.. ~ mb,oc,od,oh,ow (how many? d_crd.get_dim())
         // i is d_off/ws_off index.
         int const ddim = dcrd.get_dim();
         int const d_vl = dcrd.get_vl();
         auto const& vp = dcrd.vp; // close to raw coord vectors
         // vp[j=..ddim-1][i=0..vl) j ~ mb,oc,od,oh,ow (however many) coords
         //                         i ~ d_off and ws_off physical offset entry
         data_t src_max[MVL];
         int kpos_max[MVL];
         for (int i = 0; i<d_vl; ++i) {
             src_max[i] = numeric_limits<data_t>::lowest();
             kpos_max[i] = 0;
         }
         for (int i = 0; i<d_vl; ++i) {
             // ker_maxc is ugly, unpacking scalars and re-using old loops
             int const mb = vp[0][i];
             int const oc = vp[1][i];
             int const od = ddim >= 5? vp[ddim-3][i]: 0;
             int const oh = ddim >= 4? vp[ddim-2][i]: 0;
             int const ow = vp[ddim-1][i];
             for (int kd = 0; kd < KD; ++kd) {
                 const int id = od * SD - padF + kd;
                 if (id < 0 || id >= ID) continue;
                 for (int kh = 0; kh < KH; ++kh) {
                     const int ih = oh * SH - padT + kh;
                     if (ih < 0 || ih >= IH) continue;
                     for (int kw = 0; kw < KW; ++kw) {
                         const int iw = ow * SW - padL + kw;
                         if (iw < 0 || iw >= IW) continue;
                         // XXX fixme CoordsForNd loops for kd,kh,kw (see ds08 reo/ work)
                         const auto off = get_offset(src_d, mb, oc, id, ih, iw);
                         auto s = src[off];
                         if ( s > src_max[i] ){
                             src_max[i] = s;
                             kpos_max[i] = (kd * KH + kh) * KW + kw;
                         }
                     }
                 }
             }
         }
         for (int i = 0; i<d_vl; ++i) {
             dst[d_off[i]] = src_max[i];
             set_ws_off(ws_off[i], kpos_max[i]);
         }
     };
#endif
#if IMPL==7
     //
     // WIP -- do not use -- buggy
     //
     // XXX TODO ker_maxd which uses vec offset calc for kd,kh,kw positions too.
     // These coords are (selected) COPIES of dcrd.vp, modified so spatial dimension
     // coords 2..ddim-1 are replaced by INPUT coords as per kernel (kd,kh,kw)
     //
     // There are KD*KH*KW, so another CoordsForNd subloop is appropriate.
     auto ker_maxd = [=](dim_t const* dst_off, dim_t const* ws_off, Coords const& dcrd) {
         // d_crd.vp[j][i] for j=0.. ~ mb,oc,od,oh,ow (how many? d_crd.get_dim())
         // i is dst_off/ws_off index.
         int const ddim = dcrd.get_dim();
         int const d_vl = dcrd.get_vl();
         auto const& vp = dcrd.vp; // close to raw coord vectors
         // vp[j=..ddim-1][i=0..vl) j ~ mb,oc,od,oh,ow (however many) coords
         //                         i ~ dst_off and ws_off physical offset entry
         data_t src_max[MVL];
         int kpos_max[MVL];
         for (int di = 0; di<d_vl; ++di) {
             src_max[di] = numeric_limits<data_t>::lowest();
             kpos_max[di] = 0;
         }
         NOVECTOR for (int di = 0; di<d_vl; ++di) {
             // src: mb and oc coord limits copied
             int od = 0, oh = 0, ow = 0;
             int id0 = 0, ih0 = 0, iw0 = 0;
             Coords icrd;
             {
                 //icrd.iter_range(0,
                 //        dcrd.get_lo(0), dcrd.get_hi(0),    // mb, one value
                 //        dcrd.get_lo(1), dcrd.get_lo(1));   // oc, one value
                 // src: id,ih,iw iter ranges calculated
                 int const mb = dcrd.get_lo(0); // common value
                 int const oc = dcrd.get_lo(0); // common value
                 int c=2; // next coord limits
                 if (ddim >= 5){
                     od = dcrd.vp[ddim-3][di];
                     id0 = od * SD - padF;
                     auto id_start = max(od * SD - padF, 0);
                     auto id_end =   min(od * SD - padF + KD, ID);
                     if (id_start > id_end) id_start = id_end; // reqd?
                     icrd.iter_range(c++, id_start, id_end);
                 }
                 if (ddim >= 4) {
                     oh = dcrd.vp[ddim-2][di];
                     ih0 = oh * SH - padT;
                     auto ih_start = max(ih0, 0);
                     auto ih_end = min(ih0 + KH, IH);
                     if (ih_start > ih_end) ih_start = ih_end; // reqd?
                     icrd.iter_range(c++, ih_start, ih_end);
                 }
                 ow = dcrd.vp[ddim-1][di];
                 iw0 = ow * SW - padL;
                 auto iw_start = max(iw0, 0);
                 auto iw_end = min(iw0 + KW, IW);
                 if (iw_start > iw_end) iw_start = iw_end; // reqd?
                 icrd.iter_range(c++, iw_start, iw_end);
                 icrd.finalize();
             }


             // findmax over whole icrd window
             data_t vvmax = numeric_limits<data_t>::lowest();
             int kkpos = 0;
             for( icrd.init_nd(0); icrd; ++icrd ) { // usual 1 iter
                 int const vl = icrd.get_vl();
                 int const pos = (int)icrd.get_pos();
                 data_t s[MVL];
                 { // gather src[] data (0..vl-1)
                     dim_t srcp[MVL];
                     src_d_opt.vec_off_vtmp(icrd.base(), (dim_t *)&srcp[0], vl);
                     ShortLoop() for(unsigned j=0U; j<vl; ++j)
                             s[j] = src[srcp[j]];
                 }
                 {
                     // local vector findmax
                     data_t vmax = s[0]; //numeric_limits<data_t>::lowest();
                     int vpos = 0;
                     ShortLoop() for(unsigned j=0U; j<vl; ++j) {
                         if ( s[j] > vmax ) {
                             vmax = s[j];
                             vpos = j;
                         }
                     }
                     // update global findmax
                     if (vmax > vvmax) {
                         vvmax = vmax;
                         int kd = ddim >= 5? icrd.vp[ddim-3][vpos] - id0: 0;
                         int kh = ddim >= 4? icrd.vp[ddim-2][vpos] - ih0: 0;
                         int kw =            icrd.vp[ddim-1][vpos] - iw0   ;
                         kkpos = (kd * KH + kh) * KW + kw;
                     }
                 }
             }
             src_max[di] = vvmax;
             kpos_max[di] = kkpos;
         } // end scalar loop
         // maybe faster to wait? need to measure
         for (int di = 0; di<d_vl; ++di) { // vec scatter
             dst[dst_off[di]] = src_max[di];
         }
#ifndef NDEBUG
         if (ws && ws_dt == data_type::u8) {
             for (int di = 0; di<d_vl; ++di) { // vec scatter
                 assert(0 <= kpos_max[di] 
                         && kpos_max[di] <= numeric_limits<typename prec_traits<
                         data_type::u8>::type>::max());
             }
         }
#endif
         if (ws) {
            if (ws_dt == data_type::u8) {
                // don't we have full control over ws_d? can't its offsets be trivial?
                for (int di = 0; di<d_vl; ++di) { // scatter (not vectorizable)
                    ws[ws_off[di]] =(uint8_t)kpos_max[di];
                }
            }else{
                for (int di = 0; di<d_vl; ++di) { // vec scatter
                    reinterpret_cast<int *>(ws)[ws_off[di]] = kpos_max[di];
                }
            }
         }
     };
#endif

    auto ker_avg = [=](data_t *d, int mb, int oc, int od, int oh, int ow) {
        auto id_start = max(od * SD - padF, 0);
        auto ih_start = max(oh * SH - padT, 0);
        auto iw_start = max(ow * SW - padL, 0);
        auto id_end = min(od * SD - padF + KD, ID);
        auto ih_end = min(oh * SH - padT + KH, IH);
        auto iw_end = min(ow * SW - padL + KW, IW);

        auto num_summands = (alg == alg_kind::pooling_avg_include_padding)
                ? KW * KH * KD
                : (id_end - id_start) * (ih_end - ih_start)
                        * (iw_end - iw_start);

        acc_data_t dst = 0;
        for_(int id = id_start; id < id_end; ++id)
        for_(int ih = ih_start; ih < ih_end; ++ih)
        for (int iw = iw_start; iw < iw_end; ++iw) {
            const auto off = get_offset(src_d, mb, oc, id, ih, iw);
            dst += src[off];
        }

        d[0] = out_round<data_t>((float)dst / num_summands);
    };

    const int MB = pd()->MB();
    const int OC = pd()->C();
    const int OD = pd()->OD();
    const int OH = pd()->OH();
    const int OW = pd()->OW();

    if (alg == alg_kind::pooling_max) {
#if IMPL==0 || IMPL==1 || IMPL==2 // vectorize ker_max -- IMP setting controls that
        // XXX ||ism over output means short simd over kernel
        // VE might be better ||ism over MB,OC,OD,OH only, w/ simd over OW, KD,KH,KW?
        // if( MB * OC * OD * OH > KD*KH*KW ) { alternate impl; }
        parallel_nd(MB, OC, OD, OH, OW,
                [&](int mb, int oc, int od, int oh, int ow) {
                    data_t *d = &dst[get_offset(dst_d, mb, oc, od, oh, ow)];
                    d[0] = numeric_limits<data_t>::lowest();
                    dim_t ws_off = set_ws(mb, oc, od, oh, ow, 0);
                    ker_max(d, mb, oc, od, oh, ow, ws_off);
                });
#elif IMPL<50 // vectorize top-level
        auto elems = (size_t)MB * OC * OD * OH * OW;
        auto const ddim = dst_d.ndims();
        //printf(" elems=%ld ddim=%d\n",(long)elems, (int)ddim); fflush(stdout);
        //assert( ddim == 5 || ddim == 4 ); // old code seemed to support only these
        bool force_sequential = 0; // 1 for debug
        parallel((force_sequential? 1: 0), [&](int ithr, int nthr) {
            size_t start, end;
            balance211(elems, nthr, ithr, start, end);

            Coords dcrd(dst_d.dims(), ddim, start, end);
            for( ; dcrd; ++dcrd ) { // in vec-length chunks of dst coordinates
                int const vl = dcrd.get_vl();
                dim_t dstp[MVL]; //destination physical offsets
                //auto const& dst_vp = dcrd.base();
                //memory_desc_wrapper_opt::VecPos & dst_vp = dcrd.base();
                //using VecPos = CoordRegs<uint64_t, 6>;
                //VecPos const& dst_vp = dcrd.base();
                dst_d_opt.vec_off_v(dcrd.base(), &dstp[0], vl, false/*pad*/);
                dim_t ws_off[MVL]; 
                if (ws) {
                    ws_d_opt->vec_off_v(dcrd.base(), &ws_off[0], vl, false/*pad*/);
//#if IMPL==4
//                    for(int i=0U; i<vl; ++i){
//                        set_ws_off(ws_off[i], 0);
//                    }
//#endif
                }else{
                    ; //for(unsigned(i=0U; i<vl; ++i)
                    //  ws_off[i] = -1;
                }
#if IMPL==3
                for(int i=0U; i<vl; ++i)
                    dst[dstp[i]] = numeric_limits<data_t>::lowest();
#endif

#if IMPL==3 || IMPL==4 || IMPL==5 || IMPL>=20
                for(int i=0U; i<vl; ++i){
                    int const mb = dcrd.vp[0][i];
                    int const oc = dcrd.vp[1][i];
                    int const od = ddim >= 5? dcrd.vp[ddim-3][i]: 0;
                    int const oh = ddim >= 4? dcrd.vp[ddim-2][i]: 0;
                    int const ow = dcrd.vp[ddim-1][i];
                    //printf(" dst %d %d %d %d %d\n",mb,oc,od,oh,ow);
                    // od==0 if not needed, etc.
#if IMPL==3
                    // IGNORE ws_off :(
                    // x86 perf,cpu,,--pool --tag=aBcd16b mb1ic3ih25iw25oh23ow21kh3kw5ph0pw0,1.04077,1.12566
                    auto wsoff = set_ws(mb,oc,od,oh,ow,0);
                    ker_max(&dst[dstp[i]], mb, oc, od, oh, ow, wsoff);
#elif IMPL==4
                    // USE ws_off, also use inner impl~2
                    ker_max(&dst[dstp[i]], mb, oc, od, oh, ow, ws_off[i]);
#elif IMPL==5 || IMPL==8
                    // USE ws_off, ker_maxb
                    // x86 perf,cpu,,--pool --tag=aBcd16b mb1ic3ih25iw25oh23ow21kh3kw5ph0pw0,0.687256,0.730367
                    ker_maxb(&dst[dstp[i]], ws_off[i], mb, oc, od, oh, ow);
#endif
                }
#elif IMPL==6
                // x86 perf,cpu,,--pool --tag=aBcd16b mb1ic3ih25iw25oh23ow21kh3kw5ph0pw0,0.637695,0.647062
                ker_maxc(dstp, ws_off, dcrd);
                // .. args differ, but content same
                // (kernel loops NOT yet vectorized in ker_maxc)
#elif IMPL==7
                // not working
                ker_maxd(dstp, ws_off, dcrd);
#endif
            }
        });

#elif IMPL==50
        // options
#define SCRD 3

        auto elems = (size_t)MB * OC * OD * OH * OW;
        bool force_sequential = 0; // 1 for debug
        parallel((force_sequential? 1: 0), [&](int ithr, int nthr) {
            size_t start, end;
            balance211(elems, nthr, ithr, start, end);

            auto const dm = dst_d.ndims();
            Coords dcrd(dst_d.dims(), dm, start, end);
#if SCRD > 0
            Coords scrd;
#endif

            for( ; dcrd; ++dcrd ) { // in vec-length chunks of dst coordinates
                int const vl = dcrd.get_vl();
                dim_t dstp[MVL]; //destination physical offsets
                dst_d_opt.vec_off_v(dcrd.base(), &dstp[0], vl, false/*pad*/);
                dim_t ws_off[MVL]; 
                if (ws) {
                    ws_d_opt->vec_off_v(dcrd.base(), &ws_off[0], vl, false/*pad*/);
                }
                if(0) ker_maxc(dstp, ws_off, dcrd);
                // ker_max impl 2
                else for(int i=0U; i<vl; ++i){
                    int const mb = dcrd.vp[0][i];
                    int const oc = dcrd.vp[1][i];
                    int const od = (dm >= 5? dcrd.vp[dm-3][i]: 0);
                    int const oh = (dm >= 4? dcrd.vp[dm-2][i]: 0);
                    int const ow = dcrd.vp[dm-1][i];
                    //
                    //ker_max(&dst[dstp[i]], mb, oc, od, oh, ow, ws_off[i]);
                    //
                    int const id0 = od * SD - padF; // input coord for kernel coord kd==0
                    int const ih0 = oh * SH - padT;
                    int const iw0 = ow * SW - padL;
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
                    auto var_st  = (shift       >   0 ? shift: 0); \
                    auto var_end = (shift + ksz < isz ? shift + ksz: isz);
                    DEFINE_IN_RANGE(d_st, d_en, id0, KD, ID);
                    DEFINE_IN_RANGE(h_st, h_en, ih0, KH, IH);
                    DEFINE_IN_RANGE(w_st, w_en, iw0, KW, IW);

#if SCRD==0 // ~715
                    // scrd coords reflect mb,oc,id,ih,iw
                    auto scrd= (dm >= 5)? Coords::mk(mb,mb+1, oc,oc+1, d_st,d_en, h_st,h_en, w_st,w_en)
                            : (dm >= 4)? Coords::mk(mb,mb+1, oc,oc+1, h_st,h_en, w_st,w_en)
                            : Coords::mk(mb,mb+1, oc,oc+1, w_st,w_en); // dm>=3
#elif SCRD==1 // ~341
                    // can we re-init an existing/empty scrd?
                    //auto const dm = src_d_opt.ndims(); same as dst_d dimension
                    scrd.iter_range(0, mb, mb+1, oc,oc+1);
                    { // add spatial coords
                        int c=2; // next coord whose limits we'll add
                        if (dm >= 5) scrd.iter_range(c++, d_st, d_en);
                        if (dm >= 4) scrd.iter_range(c++, h_st, h_en);
                        scrd.iter_range(c++, w_st, w_en);
                        scrd.finalize(c); // done adding dims, recalculate full size.
                        scrd.init_nd(0);
                    }
#elif SCRD==2 // ~313 simpler fns, inline better.
                    scrd.fix_coord(0, mb).fix_coord(1, oc);
                    {
                        int c=1;
                        if (dm >= 5) scrd.fix_coord(++c, d_st, d_en);
                        if (dm >= 4) scrd.fix_coord(++c, h_st, h_en);
                        scrd.fix_coord(++c, w_st, w_en);
                        scrd.finalize(dm); // set dim, recalc full size.
                        scrd.init_nd(0);
                    }
#elif SCRD==3 // ~ 204
                    {
                        auto rlo = scrd.raw_lo(); // pointer
                        auto rhi = scrd.raw_hi();
                        *rlo++ = mb; *rhi++ = mb+1;     // mb
                        *rlo++ = oc; *rhi++ = oc+1;     // oc
                        Coords::crd_t sz = 1;
                        if (dm >= 5) {                  // id
                            *rlo++ = d_st; *rhi++ = d_en;
                            sz *= (d_en - d_st);
                            ////printf(" sz<--%ld\n",(long)sz);
                        }
                        if (dm >= 4) {                  // ih
                            *rlo++ = h_st; *rhi++ = h_en;
                            sz *= (h_en - h_st);
                            //printf(" sz<--%ld\n",(long)sz);
                        }
                        *rlo++ = w_st; *rhi++ = w_en;   // iw
                        sz *= (w_en - w_st);
                        //printf(" sz<--%ld\n",(long)sz);
                        *scrd.raw_sz() = sz;
                        *scrd.raw_dim() = dm;
                        scrd.init_nd(0);
                        //std::cout<<scrd.lim_str("scrd")<<"  "<<scrd.coord_str("scrd")<<std::endl; std::cout.flush();
                    }
#endif

                    // search krn window for srcmax and kkpos (krn posn of max)
                    data_t srcmax = numeric_limits<data_t>::lowest();
                    int kkpos = 0;
                    dim_t srcp[MVL]
                    NOVEC for ( ; scrd; ++scrd) {
                        const unsigned vl=scrd.get_vl(); // vl ~ id,ih,iw coords
                        // still uses vfrmax (VFMAX op)
                        src_d_opt.vec_off_vtmp(scrd.base(), (dim_t *)&srcp[0], vl);
                        int jmax = -1;
                        ShortLoop() for(unsigned j=0U; j<vl; ++j) {
                            auto const s= src[srcp[j]];
                            if ( s > srcmax ) {
                                srcmax = s;
                                jmax = j;
                            }
                        }

                        if (jmax >= 0 && ws) {
                            // given jmax, calc kd,kh,kw --> kpos --> ws
#if 0 && SCRD==3 // dbg
                            int kd, kh, kw; // of jmax
                            kd = dm >= 5? scrd.vp[dm-3][jmax] - id0: 0;
                            kh = dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0;
                            kw =          scrd.vp[dm-1][jmax] - iw0   ;
                            kkpos = (kd * KH + kh) * KW + kw;
                            if (kkpos < 0 || kkpos > 255)
                                //printf(" k %d,%d,%d kkpos=%d\n",kd,kh,kw,kkpos);
                            set_ws_off(ws_off[i], kkpos);
#else
                            kkpos = ((dm >= 5? scrd.vp[dm-3][jmax] - id0: 0)//kd
                                    * KH
                                    + (dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0))//kh
                                    * KW
                                    + (scrd.vp[dm-1][jmax] - iw0);//kw
#endif
                        }
                    }// iter over krn window for max

                    dst[dstp[i]] = srcmax;
                    set_ws_off(ws_off[i], kkpos);

                }//i=1..vl-1 of dst+ws
            } // for dcrd
        });
#undef SCRD
#elif IMPL==51
        // options
#define SCRD 11
        // 0 : like 50
        // 1 : VecPos32 (shorter type)
        // 2 : save vp pointers outside of loop
        // >=10 vectorize many scalar calcs (still read back as scalar)
        //       slower
        // 11 : max vec (but inner loop now does scalar reads)

        auto elems = (size_t)MB * OC * OD * OH * OW;
        bool force_sequential = 0; // 1 for debug
        parallel((force_sequential? 1: 0), [&](int ithr, int nthr) {
            size_t start, end;
            balance211(elems, nthr, ithr, start, end);

            // let's use 32-bit Crd (Pos can still be u64)
            // oh. Pos u64 stilll required by memory_desc_wrapper_opt :)
            typedef CoordsForNd<6,uint32_t,int64_t> Coords32;
            auto const dm = dst_d.ndims();
            Coords32 dcrd(dst_d.dims(), dm, start, end);
            Coords32 scrd;

            for( ; dcrd; ++dcrd ) { // in vec-length chunks of dst coordinates
                int const dvl = dcrd.get_vl();
                dim_t dstp[MVL]; //destination physical offsets
                dst_d_opt.vec_off_v(dcrd.base(), &dstp[0], dvl, false/*pad*/);
                dim_t ws_off[MVL]; 
                if (ws) {
                    ws_d_opt->vec_off_v(dcrd.base(), &ws_off[0], dvl, false/*pad*/);
                }
#if SCRD>=2
                // spatial coords of src, dst as raw int pointers
                // (VE mixed ops w/ unsigned and signed are clunky)
                static_assert( sizeof(dcrd.vp[dm-1][0]) == sizeof(int),
                        "require VecPos32");
                int const* const o_spatial0 = reinterpret_cast<int const*>
                        (&dcrd.vp[2][0]);
                int const* const s_spatial0 = reinterpret_cast<int const*>
                        (&scrd.vp[2][0]); 
#endif
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
                    auto var_st  = (shift       >   0 ? shift: 0); \
                    auto var_end = (shift + ksz < isz ? shift + ksz: isz);
#define DEFINE_IN_RANGE_VEC(idx, var_st, var_en, shift, ksz, isz) \
                    var_st[idx] = (shift[idx]       >   0 ? shift[idx]: 0); \
                    var_en[idx] = (shift[idx] + ksz < isz ? shift[idx] + ksz: isz);
#if SCRD==10
                int kk_w[MVL], iw0[MVL];
                int kk_h[MVL], ih0[MVL];
                int kk_d[MVL], id0[MVL];
                int const* o_spatial = o_spatial0;
                if (dm >= 5) {
                    ShortLoop() for (int i=0; i<dvl; ++i) {
                        id0[i] = o_spatial[i]/*od*/ * SD - padF;
                    }
                    o_spatial += dcrd.MaxVl;
                }
                if (dm >= 4) {
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        ih0[i] = o_spatial[i]/*oh*/ * SH - padT;
                    }
                    o_spatial += dcrd.MaxVl;
                }
                ShortLoop() for(int i=0; i<dvl; ++i) {
                    iw0[i] = dcrd.vp[dm-1][i]/*ow*/ * SW - padL;
                }
#endif
#if SCRD>=11
                // vector precalc (--> mem)
                int sz[MVL]; // sz < kern ovlp <= KD*KH*KW (small)
                int kk_w[MVL], iw0[MVL], w_st[MVL], w_en[MVL];
                int kk_h[MVL], ih0[MVL], h_st[MVL], h_en[MVL];
                int kk_d[MVL], id0[MVL], d_st[MVL], d_en[MVL];
                // actually, kernel size fits in int32_t
                ShortLoop() for(int i=0; i<dvl; ++i)
                        sz[i] = 1;
                int const* o_spatial = o_spatial0;
                if (dm >= 5) {
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        id0[i] = o_spatial[i]/*od*/ * SD - padF;
                        DEFINE_IN_RANGE_VEC(i, d_st, d_en, id0, KD, ID);
                        sz[i] *= d_en[i] - d_st[i];
                    }
                    o_spatial += dcrd.MaxVl;
                }
                if (dm >= 4) {
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        ih0[i] = o_spatial[i]/*oh*/ * SH - padT;
                        DEFINE_IN_RANGE_VEC(i, h_st, h_en, ih0, KH, IH);
                        sz[i] *= h_en[i] - h_st[i];
                    }
                    //if(0) NOVEC for(int i=0; i<(dvl<10?dvl:10); ++i) {
                    //    std::cout<<" ih0[i="<<i<<"]="<<ih0[i]
                    //            <<" h_st,h_en[i]="<<h_st[i]<<","<<h_en[i]
                    //            <<" sz[i] = "<<sz[i]
                    //            <<std::endl;
                    //}
                    o_spatial += dcrd.MaxVl;
                }
                ShortLoop() for(int i=0; i<dvl; ++i) {
                    iw0[i] = dcrd.vp[dm-1][i]/*ow*/ * SW - padL;
                    DEFINE_IN_RANGE_VEC(i, w_st, w_en, iw0, KW, IW);
                    sz[i] *= w_en[i] - w_st[i];
                }
                //if(0) NOVEC for(int i=0; i<(dvl<10?dvl:10); ++i) {
                //    std::cout<<" iw0[i="<<i<<"]="<<iw0[i]
                //            <<" w_st,w_en[i]="<<w_st[i]<<","<<w_en[i]
                //            <<" sz[i] = "<<sz[i]
                //            <<std::endl;
                //}
                //if(0) std::cout<<" dvl="<<dvl
                //        <<" d:"<<d_st[0]<<"--"<<d_en[0]
                //        <<" h:"<<h_st[0]<<"--"<<h_en[0]
                //        <<" w:"<<w_st[0]<<"--"<<w_en[0]
                //        <<" sz:"<<sz[0]
                //        <<std::endl;
                //if(0) std::cout.flush();
#endif

                for(int i=0U; i<dvl; ++i){
                    int const mb = dcrd.vp[0][i];
                    int const oc = dcrd.vp[1][i];
#if SCRD<2
                    int const od = (dm >= 5? dcrd.vp[dm-3][i]: 0);
                    int const oh = (dm >= 4? dcrd.vp[dm-2][i]: 0);
                    int const ow = dcrd.vp[dm-1][i];
#elif SCRD<10
                    int const* o_spatial = o_spatial0;
                    int od = 0, oh=0;
                    if (dm >= 5) { od = o_spatial[i]; o_spatial += dcrd.MaxVl; }
                    if (dm >= 4) { oh = o_spatial[i]; o_spatial += dcrd.MaxVl; }
                    int const ow = o_spatial[i];
#endif
                    //
                    //ker_max(&dst[dstp[i]], mb, oc, od, oh, ow, ws_off[i]);
                    //
#if SCRD<10
                    int const id0 = od * SD - padF; // input coord for kernel coord kd==0
                    int const ih0 = oh * SH - padT;
                    int const iw0 = ow * SW - padL;
                    DEFINE_IN_RANGE(d_st, d_en, id0, KD, ID);
                    DEFINE_IN_RANGE(h_st, h_en, ih0, KH, IH);
                    DEFINE_IN_RANGE(w_st, w_en, iw0, KW, IW);
                    {
                        auto rlo = scrd.raw_lo(); // pointer
                        auto rhi = scrd.raw_hi();
                        *rlo++ = mb; *rhi++ = mb+1;     // mb
                        *rlo++ = oc; *rhi++ = oc+1;     // oc
                        Coords::crd_t sz = 1;
                        if (dm >= 5) {                  // id
                            *rlo++ = d_st; *rhi++ = d_en;
                            sz *= (d_en - d_st);
                        }
                        if (dm >= 4) {                  // ih
                            *rlo++ = h_st; *rhi++ = h_en;
                            sz *= (h_en - h_st);
                        }
                        *rlo++ = w_st; *rhi++ = w_en;   // iw
                        sz *= (w_en - w_st);
                        *scrd.raw_sz() = sz;
                        *scrd.raw_dim() = dm;
                        scrd.init_nd(0);
                    }
#elif SCRD==10
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
                    auto var_st  = (shift       >   0 ? shift: 0); \
                    auto var_end = (shift + ksz < isz ? shift + ksz: isz);
                    DEFINE_IN_RANGE(d_st, d_en, id0[i], KD, ID);
                    DEFINE_IN_RANGE(h_st, h_en, ih0[i], KH, IH);
                    DEFINE_IN_RANGE(w_st, w_en, iw0[i], KW, IW);
                    {
                        auto rlo = scrd.raw_lo(); // pointer
                        auto rhi = scrd.raw_hi();
                        *rlo++ = mb; *rhi++ = mb+1;     // mb
                        *rlo++ = oc; *rhi++ = oc+1;     // oc
                        Coords::crd_t sz = 1;
                        if (dm >= 5) {                  // id
                            *rlo++ = d_st; *rhi++ = d_en;
                            sz *= (d_en - d_st);
                        }
                        if (dm >= 4) {                  // ih
                            *rlo++ = h_st; *rhi++ = h_en;
                            sz *= (h_en - h_st);
                        }
                        *rlo++ = w_st; *rhi++ = w_en;   // iw
                        sz *= (w_en - w_st);
                        *scrd.raw_sz() = sz;
                        *scrd.raw_dim() = dm;
                        scrd.init_nd(0);
                        //if(0) std::cout<<scrd.lim_str("scrd")<<"  "<<scrd.coord_str("scrd")<<std::endl; std::cout.flush();
                    }
#elif SCRD>10 // max vector precalc, more mem read now:
                    {
                        auto rlo = scrd.raw_lo(); // pointer
                        auto rhi = scrd.raw_hi();
                        *rlo++ = mb; *rhi++ = mb+1;     // mb
                        *rlo++ = oc; *rhi++ = oc+1;     // oc
                        if (dm >= 5) {                  // id
                            *rlo++ = d_st[i]; *rhi++ = d_en[i];
                        }
                        if (dm >= 4) {                  // ih
                            *rlo++ = h_st[i]; *rhi++ = h_en[i];
                        }
                        *rlo++ = w_st[i]; *rhi++ = w_en[i];   // iw
                        *scrd.raw_sz() = sz[i]; // krn ovlp sz precalc'ed
                        *scrd.raw_dim() = dm;
                        scrd.init_nd(0);
                        //if(0) std::cout<<scrd.lim_str("scrd")<<"  "<<scrd.coord_str("scrd")<<std::endl; std::cout.flush();
                    }
#endif

                    // search krn window for srcmax and kkpos (krn posn of max)
                    data_t srcmax = numeric_limits<data_t>::lowest();
                    int kkpos = 0;
                    dim_t srcp[MVL]
                    NOVEC for ( ; scrd; ++scrd) {
                        const unsigned svl=scrd.get_vl(); // svl ~ id,ih,iw coords
                        // still uses vfrmax (VFMAX op)
                        src_d_opt.vec_off_vtmp(scrd.base(), (dim_t *)&srcp[0], svl);
                        int jmax = -1;
                        ShortLoop() for(unsigned j=0U; j<svl; ++j) {
                            auto const s= src[srcp[j]];
                            if ( s > srcmax ) {
                                srcmax = s;
                                jmax = j;
                            }
                        }

                        if (jmax >= 0 && ws) {
                            // given jmax, calc kd,kh,kw --> kpos --> ws
#if SCRD<2
                            kkpos = ((dm >= 5? scrd.vp[dm-3][jmax] - id0: 0)//kd
                                    * KH
                                    + (dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0))//kh
                                    * KW
                                    + (scrd.vp[dm-1][jmax] - iw0);//kw
#elif SCRD<10
                            //int kkpos_0 = ((dm >= 5? scrd.vp[dm-3][jmax] - id0: 0)//kd
                            //        * KH
                            //        + (dm >= 4? scrd.vp[dm-2][jmax] - ih0: 0))//kh
                            //        * KW
                            //        + (scrd.vp[dm-1][jmax] - iw0);//kw
                            kkpos = 0;
                            int const* s_spatial = s_spatial0;
                            if (dm >= 5) { // ? init as kh * KH
                                kkpos = ((int)s_spatial[jmax] - id0) * KH;
                                s_spatial += scrd.MaxVl;
                            }
                            if (dm >= 4) { // ? add kh, then mult by KW
                                kkpos = (kkpos + ((int)s_spatial[jmax] - ih0)) * KW;
                                s_spatial += scrd.MaxVl;
                            }
                            kkpos += s_spatial[jmax] - iw0;

#else
                            int const* s_spatial = s_spatial0;
                            // save spatial ih coords (vectorize the kkpos calc post-loop)
                            if (dm >=5 ) {
                                kk_d[i] = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            if (dm >=4 ) {
                                kk_h[i] = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            kk_w[i] = s_spatial[jmax];
#endif
                        }
                    }// iter over krn window for max

                    dst[dstp[i]] = srcmax;
#if SCRD<10
                    if (ws)
                        set_ws_off(ws_off[i], kkpos);
#endif

                }//i=1..dvl-1 of dst+ws
#if SCRD>=10
                if (ws) {
                    // vec xform kk_d,h,w to kkpos, then updata ws
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        int kkpos = 0;
                        if (dm >= 5) { // ? init to kd * KH
                            kkpos = (kk_d[i] - id0[i]) * KH;
                        }
                        if (dm >= 4) { // ? add kh, then mult by KW
                            kkpos = (kkpos + kk_h[i] - ih0[i]) * KW;
                        }
                        kkpos += kk_w[i] - iw0[i];
                        // vectorize this whole routine
                        //set_ws_off(ws_off[i], kkpos);
                        if (ws_dt == data_type::u8) {
                            //assert(0 <= value
                            //        && value <= numeric_limits<typename prec_traits<
                            //        data_type::u8>::type>::max());
                            ws[ws_off[i]] = kkpos;
                        } else
                            reinterpret_cast<int *>(ws)[ws_off[i]] = kkpos;
                    }
                }
#endif
            } // for dcrd
        });
#undef FOR_vl
#undef DEFINE_IN_RANGE
#undef DEFINE_IN_RANGE_VEC
#undef SCRD
#elif IMPL==52
        // options
#define SCRD 0
        // 0 : like 51:11
        // 1 : Alt kk_dhw memory storage pattern (no diff)

        auto elems = (size_t)MB * OC * OD * OH * OW;
        bool force_sequential = 0; // 1 for debug
        parallel((force_sequential? 1: 0), [&](int ithr, int nthr) {
            size_t start, end;
            balance211(elems, nthr, ithr, start, end);

            // let's use 32-bit Crd (Pos can still be u64)
            // oh. Pos u64 stilll required by memory_desc_wrapper_opt :)
            typedef CoordsForNd<6,uint32_t,int64_t> Coords32;
            auto const dm = dst_d.ndims();
            Coords32 dcrd(dst_d.dims(), dm, start, end);
            Coords32 scrd;

            for( ; dcrd; ++dcrd ) { // in vec-length chunks of dst coordinates
                int const dvl = dcrd.get_vl();
                dim_t dstp[MVL]; //destination physical offsets
                dst_d_opt.vec_off_v(dcrd.base(), &dstp[0], dvl, false/*pad*/);
                dim_t ws_off[MVL]; 
                if (ws) {
                    ws_d_opt->vec_off_v(dcrd.base(), &ws_off[0], dvl, false/*pad*/);
                }
                // spatial coords of src, dst as raw int pointers
                // (VE mixed ops w/ unsigned and signed are clunky)
                static_assert( sizeof(dcrd.vp[dm-1][0]) == sizeof(int),
                        "require VecPos32");
                int const* const o_spatial0 = reinterpret_cast<int const*>
                        (&dcrd.vp[2][0]);
                int const* const s_spatial0 = reinterpret_cast<int const*>
                        (&scrd.vp[2][0]); 
#define DEFINE_IN_RANGE(var_st, var_end, shift, ksz, isz) \
                    auto var_st  = (shift       >   0 ? shift: 0); \
                    auto var_end = (shift + ksz < isz ? shift + ksz: isz);
#define DEFINE_IN_RANGE_VEC(idx, var_st, var_en, shift, ksz, isz) \
                    var_st[idx] = (shift[idx]       >   0 ? shift[idx]: 0); \
                    var_en[idx] = (shift[idx] + ksz < isz ? shift[idx] + ksz: isz);
                // vector precalc (--> mem)
                int sz[MVL]; // sz < kern ovlp <= KD*KH*KW (small)
#if SCRD==0
                int kk_w[MVL], iw0[MVL], w_st[MVL], w_en[MVL];
                int kk_h[MVL], ih0[MVL], h_st[MVL], h_en[MVL];
                int kk_d[MVL], id0[MVL], d_st[MVL], d_en[MVL];
#else
                int kk_dhw[3*MVL];
                int iw0[MVL], w_st[MVL], w_en[MVL];
                int ih0[MVL], h_st[MVL], h_en[MVL];
                int id0[MVL], d_st[MVL], d_en[MVL];
#endif
                // actually, kernel size fits in int32_t
                ShortLoop() for(int i=0; i<dvl; ++i)
                        sz[i] = 1;
                int const* o_spatial = o_spatial0;
                if (dm >= 5) {
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        id0[i] = o_spatial[i]/*od*/ * SD - padF;
                        DEFINE_IN_RANGE_VEC(i, d_st, d_en, id0, KD, ID);
                        sz[i] *= d_en[i] - d_st[i];
                    }
                    o_spatial += dcrd.MaxVl;
                }
                if (dm >= 4) {
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        ih0[i] = o_spatial[i]/*oh*/ * SH - padT;
                        DEFINE_IN_RANGE_VEC(i, h_st, h_en, ih0, KH, IH);
                        sz[i] *= h_en[i] - h_st[i];
                    }
                    o_spatial += dcrd.MaxVl;
                }
                ShortLoop() for(int i=0; i<dvl; ++i) {
                    iw0[i] = dcrd.vp[dm-1][i]/*ow*/ * SW - padL;
                    DEFINE_IN_RANGE_VEC(i, w_st, w_en, iw0, KW, IW);
                    sz[i] *= w_en[i] - w_st[i];
                }
#if SCRD>0 // linear iter for remembering kk_dhw[]
                auto pkk_dhw = &kk_dhw[0];
#endif
                for(int i=0U; i<dvl; ++i){
                    int const mb = dcrd.vp[0][i];
                    int const oc = dcrd.vp[1][i];
                    //
                    //ker_max(&dst[dstp[i]], mb, oc, od, oh, ow, ws_off[i]);
                    //
                    {
                        auto rlo = scrd.raw_lo(); // pointer
                        auto rhi = scrd.raw_hi();
                        *rlo++ = mb; *rhi++ = mb+1;     // mb
                        *rlo++ = oc; *rhi++ = oc+1;     // oc
                        if (dm >= 5) {                  // id
                            *rlo++ = d_st[i]; *rhi++ = d_en[i];
                        }
                        if (dm >= 4) {                  // ih
                            *rlo++ = h_st[i]; *rhi++ = h_en[i];
                        }
                        *rlo++ = w_st[i]; *rhi++ = w_en[i];   // iw
                        *scrd.raw_sz() = sz[i]; // krn ovlp sz precalc'ed
                        *scrd.raw_dim() = dm;
                        scrd.init_nd(0);
                    }

                    // search krn window for srcmax and kkpos (krn posn of max)
                    data_t srcmax = numeric_limits<data_t>::lowest();
                    int kkpos = 0;
                    dim_t srcp[MVL]
                    NOVEC for ( ; scrd; ++scrd) {
                        const unsigned svl=scrd.get_vl(); // svl ~ id,ih,iw coords
                        // still uses vfrmax (VFMAX op)
                        src_d_opt.vec_off_vtmp(scrd.base(), (dim_t *)&srcp[0], svl);
                        int jmax = -1;
                        ShortLoop() for(unsigned j=0U; j<svl; ++j) {
                            auto const s= src[srcp[j]];
                            if ( s > srcmax ) {
                                srcmax = s;
                                jmax = j;
                            }
                        }

                        // ? use a raw kk ptr  instead of 3 vector kk_d,h,w[]
                        if (jmax >= 0 && ws) {
                            // given jmax, calc kd,kh,kw --> kpos --> ws
                            int const* s_spatial = s_spatial0;
                            // save spatial ih coords (vectorize the kkpos calc post-loop)
#if SCRD==0
                            if (dm >=5 ) {
                                kk_d[i] = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            if (dm >=4 ) {
                                kk_h[i] = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            kk_w[i] = s_spatial[jmax];
#else
                            if (dm >=5 ) {
                                *pkk_dhw++ = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            if (dm >=4 ) {
                                *pkk_dhw++ = s_spatial[jmax];
                                s_spatial += scrd.MaxVl;
                            }
                            *pkk_dhw++ = s_spatial[jmax];
#endif
                        }
                    }// iter over krn window for max

                    dst[dstp[i]] = srcmax;

                }//i=1..dvl-1 of dst+ws
                if (ws) {
#if SCRD==0 // this vectorizes
                    // vec xform kk_d,h,w[] to kkpos, then updata ws
                    // mb10 ~ 2110 ms
                    ShortLoop() for(int i=0; i<dvl; ++i) {
                        int kkpos = 0;
                        if (dm >= 5) { // ? init to kd * KH
                            kkpos = (kk_d[i] - id0[i]) * KH;
                        }
                        if (dm >= 4) { // ? add kh, then mult by KW
                            kkpos = (kkpos + kk_h[i] - ih0[i]) * KW;
                        }
                        kkpos += kk_w[i] - iw0[i];
                        // vectorize this whole routine
                        //set_ws_off(ws_off[i], kkpos);
                        if (ws_dt == data_type::u8) {
                            //assert(0 <= value
                            //        && value <= numeric_limits<typename prec_traits<
                            //        data_type::u8>::type>::max());
                            ws[ws_off[i]] = kkpos;
                        } else
                            reinterpret_cast<int *>(ws)[ws_off[i]] = kkpos;
                    }
#elif SCRD==1 // VE likes conditionals moved out, for vectorization
                    // each dvl<MVL "loop" is one or more simple vector ops
                    //
                    // Alt. memory pattern ~ faster, for large data
                    //
                    // mb10 ~ 1962.4 ms
                    int kkpos[MVL]; VREG(kkpos);
                    if (dm >= 5) {
                        ShortLoop() for(int i=0; i<dvl; ++i) {
                            int d = kk_dhw[3*i];
                            int h = kk_dhw[3*i+1];
                            int w = kk_dhw[3*i+2];
                            kkpos[i] = ((d - id0[i]) * KH
                                    + (h - ih0[i])) * KW
                                    + (w - iw0[i]);
                        }
                    }else if (dm >= 4) {
                        ShortLoop() for(int i=0; i<dvl; ++i) {
                            int h = kk_dhw[2*i];
                            int w = kk_dhw[2*i+1];
                            kkpos[i] = (h - ih0[i]) * KW
                                    + (w - iw0[i]);
                        }
                    }else{
                        ShortLoop() for(int i=0; i<dvl; ++i) {
                            kkpos[i] = kk_dhw[i] - iw0[i];
                        }
                    }
                    if (ws_dt == data_type::u8) {
                        ShortLoop() for(int i=0; i<dvl; ++i) {
                            //assert(0 <= value
                            //        && value <= numeric_limits<typename prec_traits<
                            //        data_type::u8>::type>::max());
                            ws[ws_off[i]] = kkpos[i];
                        }
                    } else {
                        ShortLoop() for(int i=0; i<dvl; ++i) {
                            reinterpret_cast<int *>(ws)[ws_off[i]] = kkpos[i];
                        }
                    }
#endif
                }
            } // for dcrd
        });
#undef FOR_vl
#undef DEFINE_IN_RANGE
#undef DEFINE_IN_RANGE_VEC
#undef SCRD
#endif
    } else {
        parallel_nd(MB, OC, OD, OH, OW,
                [&](int mb, int oc, int od, int oh, int ow) {
                    data_t *d = &dst[get_offset(dst_d, mb, oc, od, oh, ow)];
                    d[0] = 0;
                    ker_avg(d, mb, oc, od, oh, ow);
                });
    }
}

template <data_type_t data_type>
void ref_pooling_bwd_t<data_type>::execute_backward(
        const exec_ctx_t &ctx) const {

    auto diff_dst = CTX_IN_MEM(const data_t *, DNNL_ARG_DIFF_DST);
    auto ws = CTX_IN_MEM(const unsigned char *, DNNL_ARG_WORKSPACE);
    auto diff_src = CTX_OUT_MEM(data_t *, DNNL_ARG_DIFF_SRC);

    const memory_desc_wrapper diff_dst_d(pd()->diff_dst_md());
    const memory_desc_wrapper diff_src_d(pd()->diff_src_md());
    const memory_desc_wrapper ws_d(pd()->workspace_md());

    const memory_desc_wrapper_opt diff_src_d_opt(diff_src_d.md_);
    const memory_desc_wrapper_opt diff_dst_d_opt(diff_dst_d.md_);
    memory_desc_wrapper_opt *ws_d_opt{nullptr};

    const auto alg = pd()->desc()->alg_kind;

    if (ws) {
        //mdw_prt("yes ws:", ws_d);
        assert(alg == alg_kind::pooling_max);
        assert( ws_d.format_kind() == format_kind::blocked );
        // avoid init and setup cost if possible
        ws_d_opt = new memory_desc_wrapper_opt(ws_d.md_);
    }else{
        //mdw_prt("no ws:", ws_d);
    }

    const int ID = pd()->ID();
    const int IH = pd()->IH();
    const int IW = pd()->IW();
    const int KD = pd()->KD();
    const int KH = pd()->KH();
    const int KW = pd()->KW();
    const int SD = pd()->KSD();
    const int SH = pd()->KSH();
    const int SW = pd()->KSW();
    const int padF = pd()->padFront();
    const int padT = pd()->padT();
    const int padL = pd()->padL();

    auto ker_zero = [=](int mb, int oc) {
        for_(int id = 0; id < ID; ++id)
        for_(int ih = 0; ih < IH; ++ih)
        for (int iw = 0; iw < IW; ++iw) {
            const auto off = get_offset(diff_src_d, mb, oc, id, ih, iw);
            diff_src[off] = data_type_t(0);
        }
    };

    auto ker_max
            = [=](const data_t *d, int mb, int oc, int od, int oh, int ow) {
                  const auto ws_off = get_offset(ws_d, mb, oc, od, oh, ow);
                  const int index = ws_d.data_type() == data_type::u8
                          ? (int)ws[ws_off]
                          : ((int *)ws)[ws_off];
                  const int kd = (index / KW) / KH;
                  const int kh = (index / KW) % KH;
                  const int kw = index % KW;
                  const int id = od * SD - padF + kd;
                  const int ih = oh * SH - padT + kh;
                  const int iw = ow * SW - padL + kw;

                  // If padding area could fit the kernel,
                  // then input displacement would be out of bounds.
                  // No need to back propagate there as padding is
                  // virtual in pooling_max case.
                  if (id < 0 || id >= ID) return;
                  if (ih < 0 || ih >= IH) return;
                  if (iw < 0 || iw >= IW) return;

                  const auto off = get_offset(diff_src_d, mb, oc, id, ih, iw);
                  diff_src[off] += d[0];
              };

    auto ker_avg = [=](const data_t *d, int mb, int oc, int od, int oh,
                           int ow) {
        auto id_start = max(od * SD - padF, 0);
        auto ih_start = max(oh * SH - padT, 0);
        auto iw_start = max(ow * SW - padL, 0);
        auto id_end = min(od * SD - padF + KD, ID);
        auto ih_end = min(oh * SH - padT + KH, IH);
        auto iw_end = min(ow * SW - padL + KW, IW);

        auto num_summands = (alg == alg_kind::pooling_avg_include_padding)
                ? KW * KH * KD
                : (id_end - id_start) * (ih_end - ih_start)
                        * (iw_end - iw_start);

        for_(int id = id_start; id < id_end; ++id)
        for_(int ih = ih_start; ih < ih_end; ++ih)
        for (int iw = iw_start; iw < iw_end; ++iw) {
            const auto off = get_offset(diff_src_d, mb, oc, id, ih, iw);
            diff_src[off] += d[0] / num_summands;
        }
    };

    const int MB = pd()->MB();
    const int OC = pd()->C();
    const int OD = pd()->OD();
    const int OH = pd()->OH();
    const int OW = pd()->OW();

    int ow_start = max(0, utils::div_up(padL - KW + 1, SW));
    int ow_end = min(OW, 1 + (padL + IW - 1) / SW);

    int oh_start = max(0, utils::div_up(padT - KH + 1, SH));
    int oh_end = min(OH, 1 + (padT + IH - 1) / SH);

    int od_start = max(0, utils::div_up(padF - KD + 1, SD));
    int od_end = min(OD, 1 + (padF + ID - 1) / SD);

    typedef CoordsForNd<6,uint64_t,uint64_t> Coords;

    if (alg == alg_kind::pooling_max) {
        parallel_nd(MB, OC, [&](int mb, int oc) {
            ker_zero(mb, oc);
            for_(int od = od_start; od < od_end; ++od)
            for_(int oh = oh_start; oh < oh_end; ++oh)
            for (int ow = ow_start; ow < ow_end; ++ow) {
                const data_t *d
                        = &diff_dst[get_offset(diff_dst_d, mb, oc, od, oh, ow)];
                ker_max(d, mb, oc, od, oh, ow);
            }
        });
#define BIMPL 1
#if BIMPL==0
        parallel_nd(MB, OC, [&](int mb, int oc) {
            ker_zero(mb, oc);
            for_(int od = od_start; od < od_end; ++od)
            for_(int oh = oh_start; oh < oh_end; ++oh)
            for (int ow = ow_start; ow < ow_end; ++ow) {
                const data_t *d
                        = &diff_dst[get_offset(diff_dst_d, mb, oc, od, oh, ow)];
                //printf("ker_max(%p,%d,%d,%d,%d,%d)\n",(void*)d,mb,oc,od,oh,ow);
                ker_max(d, mb, oc, od, oh, ow);
            }
        });
#elif BIMPL==1 // small amount of vectorization calls
        //parallel_nd(MB, OC, [&](int mb, int oc) {
        auto nouter = (dim_t)MB * OC;
        auto ninner = (dim_t)(od_end - od_start) * (oh_end - oh_start) * (ow_end - ow_start);
        bool force_sequential = 0; // 1 for debug
        parallel((force_sequential? 1: 0), [&](int ithr, int nthr) {
            auto ddim = diff_dst_d.ndims();
            //assert(diff_src_d.ndims() == ddim);

            Coords icrd;
            icrd.iter_range(0, 0,1, 0,1); // md and oc dimension placeholders
            { // add spatial coords
                int c=2; // next coord whose limits we'll add
                if (ddim >= 5) icrd.iter_range(c++, 0, ID);
                if (ddim >= 4) icrd.iter_range(c++, 0, IH);
                icrd.iter_range(c++, 0, IW);
                icrd.finalize(); // done adding dims, recalculate full size.
            }

            Coords dcrd;
            dcrd.iter_range(0, 0,1, 0,1); // md and oc dimension placeholders
            //assert( dcrd.get_dim() == 2 );
            //printf(" ddim=%d dcrd.get_dim()=%d\n", (int)ddim, (int)dcrd.get_dim());
            { // add spatial coords
                int c=2; // next coord whose limits we'll add
                if (ddim >= 5) dcrd.iter_range(c++, od_start, od_end);
                if (ddim >= 4) dcrd.iter_range(c++, oh_start, oh_end);
                dcrd.iter_range(c++, ow_start, ow_end);
                dcrd.finalize(); // done adding dims, recalculate full size.
            }
            //printf(" ddim=%d dcrd.get_dim()=%d\n", (int)ddim, (int)dcrd.get_dim());
            // Note: vl still zero, and vp[][] unset, until init_nd(start[,end])
            //std::cout<<dcrd.lim_str()<<"  "<<dcrd.coord_str()<<std::endl;
            ///std::cout.flush();
            //assert( ddim == dcrd.get_dim() );
            //assert( ninner == dcrd.get_sz() );

            dim_t ostart, oend;
            balance211(nouter, nthr, ithr, ostart, oend);
            for(size_t oo=ostart; oo<oend; ++oo){ // outer coords
                int const mb = oo / OC;
                int const oc = oo % OC;

#if 0
                ker_zero(mb, oc);
#else
                // if dense, much faster (don't care about internal order) XXX
                icrd.fix_coord(0,mb).fix_coord(1,oc); // sz unchanged
                //icrd.init_nd(0);
                //std::cout<<icrd.lim_str("icrd")<<"  "<<icrd.coord_str("icrd")<<std::endl; std::cout.flush();
                for ( icrd.init_nd(0); icrd; ++icrd) { // inner coords
                    auto const vl = icrd.get_vl();
                    dim_t diff_src_off[MVL];
                    diff_src_d_opt.vec_off_v(icrd.base(), &diff_src_off[0],
                            vl, false/*pad*/);
                    for (int i=0; i<vl; ++i)
                        diff_src[diff_src_off[i]] = data_t{0};
                }
#endif

                // dcrd has mb,oc coords fixed.
                dcrd.fix_coord(0,mb).fix_coord(1,oc); // sz unchanged
                //dcrd.init_nd(0);
                //std::cout<<dcrd.lim_str()<<"  "<<dcrd.coord_str()<<std::endl; std::cout.flush();
                for (dcrd.init_nd(0); dcrd; ++dcrd) { // inner coords
                    int const vl = dcrd.get_vl();
                    dim_t diff_dst_off[MVL];
                    diff_dst_d_opt.vec_off_v(dcrd.base(), &diff_dst_off[0],
                            vl, false/*pad*/);
                    for (int i=0; i<vl; ++i) {
                        int c = 1; // after oc-dim, have spatial coords
                        int const od = ddim >= 5? dcrd.vp[++c][i]: 0;
                        int const oh = ddim >= 4? dcrd.vp[++c][i]: 0;
                        int const ow = dcrd.vp[++c][i];
                        const data_t * d = &diff_dst[diff_dst_off[i]];
                        //printf("i=%d ker_max(%p,%d,%d,%d,%d,%d)\n",i,(void*)d,mb,oc,od,oh,ow);
                        //assert( dcrd.vp[0][i] == mb );
                        //assert( dcrd.vp[1][i] == oc );
                        //assert( diff_dst_off[i] == get_offset(diff_dst_d,mb,oc,od,oh,ow) );
                        ker_max(d, mb, oc, od, oh, ow);
                    }
                }
            }
        });
#else
#error "BIMPL unknown"
#endif
    } else {
        parallel_nd(MB, OC, [&](int mb, int oc) {
            ker_zero(mb, oc);
            for_(int od = od_start; od < od_end; ++od)
            for_(int oh = oh_start; oh < oh_end; ++oh)
            for (int ow = ow_start; ow < ow_end; ++ow) {
                const data_t *d
                        = &diff_dst[get_offset(diff_dst_d, mb, oc, od, oh, ow)];
                ker_avg(d, mb, oc, od, oh, ow);
            }
        });
    }
}

template struct ref_pooling_fwd_t<data_type::f32>;
template struct ref_pooling_fwd_t<data_type::s32>;
template struct ref_pooling_fwd_t<data_type::bf16, data_type::f32>;
template struct ref_pooling_fwd_t<data_type::s8, data_type::s32>;
template struct ref_pooling_fwd_t<data_type::u8, data_type::s32>;

template struct ref_pooling_bwd_t<data_type::f32>;
template struct ref_pooling_bwd_t<data_type::s32>;
template struct ref_pooling_bwd_t<data_type::bf16>;
} // namespace cpu
} // namespace impl
} // namespace dnnl

// vim: et ts=4 sw=4 cindent cino=+2s,l0,\:4,N-s
